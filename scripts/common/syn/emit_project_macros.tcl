# Copyright 2022 Intel Corporation
# SPDX-License-Identifier: MIT

namespace eval options {
	variable optionMap
}

if { [info exists ::options::optionMap] } {
	array unset ::options::optionMap
}
array set ::options::optionMap {}

#************************************************
#
# Description: Parse the input arguments to the script
#
#************************************************
proc SubParseCMDArguments {} {
  global argv
  global argc

  set singleOptionMap(--project) 0
  set singleOptionMap(--revision) 0
  set singleOptionMap(--output) 0

  set success 1
  set i 0

  while { ($i < $argc) && ($success==1) } {
          set arg [lindex $argv $i]
          incr i

          set optList [split $arg "="]
          set opt [lindex $optList 0]

          if [info exists singleOptionMap($opt)] {
                  if { $singleOptionMap($opt) == 0 } {
                          if { [llength $optList] < 2 } {
                                  set success 0
                                  puts "Error: No value is specified for option $opt"
                          } elseif { [llength $optList] > 2 } {
                                  set success 0
                                  puts "Error: Illegal option found \"$arg\"."
                          } else {
                                  set optValue [lindex $optList 1]
                                  if [string equal $optValue ""] {
                                          set success 0
                                          puts "Error: No value is specified for option $opt"
                                  } else {
                                          set ::options::optionMap($opt) $optValue
                                  }
                          }
                  } else {
                          if { [llength $optList] == 1 } {
                                  set ::options::optionMap($arg) 1
                          } else {
                                  set success 0
                                  puts "Error: Illegal option found \"$arg\"."
                          }
                  }
          } else {
                  set success 0
                  puts "Error: $arg is not a valid option."
          }
  }

  if { $success == 1 } {
          foreach opt [array names singleOptionMap] {
                  if { $singleOptionMap($opt) == 0 } {
                          if { ![info exists ::options::optionMap($opt)] } {
                                  puts "Error: Missing $opt option."
                                  set success 0
                          }
                  }
          }
  }

  if {$success != 1 } {
          SubPrintHelp
          return -1
  } 
}

#************************************************
# Description: Print the HELP info
#************************************************
proc SubPrintHelp {} {
   puts "This script emits all the macros defined in a project."
   puts "Usage: emit_project_macros.tcl <option>.."
   puts "Supported options:"
   puts "    --project <project>         "
   puts "    --revision <revision>       "
   puts "    --output <output file>      "
}


proc emitMacros {} {
  set project $::options::optionMap(--project)
  set revision $::options::optionMap(--revision)
  set output_fname $::options::optionMap(--output)

  project_open -revision $revision $project

  set ofile [open $output_fname w]

  puts $ofile "##"
  puts $ofile "## Verilog macros read from ${project} ${revision}"
  puts $ofile "##"
  puts $ofile "## Generated by emit_project_macros.tcl"
  puts $ofile "##\n"

  set macro_col [get_all_global_assignments -name VERILOG_MACRO]
  foreach_in_collection m $macro_col {
    set t [lindex $m 2]
    # Emit everything but OPAE_PLATFORM_GEN, which is a tag used during
    # out-of-tree PR release creation.
    if { $t != "OPAE_PLATFORM_GEN" } {
      puts $ofile $t
    }
  }

  close $ofile
  project_close
}

#************************************************
# Description: Entry point of TCL post processing
#************************************************
proc main {} {
  if { [SubParseCMDArguments] == -1 } {
    return -1
  }

  emitMacros
}

main
