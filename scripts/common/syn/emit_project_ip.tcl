# Copyright 2022 Intel Corporation
# SPDX-License-Identifier: MIT

##
## Invoke from quartus_ipgenerate -t.
##
## Read the collection of IP files (IP and QSYS) from a project and emit
## a Tcl file that loads them into Quartus. OFS uses this script to pass
## the FIM's set of IP files from a base build to a PR build. OFS PR
## builds don't load FIM sources, unless required, so the FIM source
## specification of IPs can't be reused easily. Quartus requires access
## to all base build IP in a PR build. This script automates base build
## IP management in PR builds.
##

# Add tcl_lib subdirectory of this script to package search path
lappend auto_path [file join [pwd] [file dirname [info script]] tcl_lib]
# OFS script for parsing command line options
package require options


#************************************************
# Description: Print the HELP info
#************************************************
proc PrintHelp {} {
   puts "This script emits all the IP files defined in a project."
   puts "Usage: emit_project_ip.tcl --project=<proj> --revision=<rev> \[--output=fname\]"
   puts "                           \[--mode=<tcl|ip_lib|sync>\] \[--verbose=1\]"
   puts ""
   puts "Supported options:"
   puts "    --project=<project>"
   puts "    --revision=<revision>"
   puts "    --output=<output file>   (writes to stdout if not set)"
   puts "    --mode=<tcl|ip_lib|sync> (default: tcl)"
   puts "         tcl emits a Quartus Tcl script that loads the project's IP"
   puts "         ip_lib copies project IP into the ../ip_lib/ tree"
   puts "         sync copies project IP from the ../ip_lib/ tree back to the source IP"
   puts "    --verbose=1              (more information about file copying)"
   puts ""
   puts "Mode sync can be used after adding or upgrading IP within a Quartus project"
   puts "to move local IP files in ../ip_lib/ back to the git source tree."
}


proc emitIP {} {
  set project $::options::optionMap(--project)
  set revision $::options::optionMap(--revision)

  project_open -revision $revision $project
  set ip_file [get_project_ip_files]

  if [info exists ::options::optionMap(--output)] {
    set ofile [open $::options::optionMap(--output) w]
  } else {
    set ofile stdout
  }

  puts $ofile "##"
  puts $ofile "## IP inherited from the base FIM build from ${project} ${revision}"
  puts $ofile "##"
  puts $ofile "## Generated by OFS emit_project_ip.tcl"
  puts $ofile "##\n"

  foreach m $ip_file {
    # Unfortunately, Quartus converts IP file paths to absolute. We want the
    # paths to be relative. Use the realpath program to do this. The FIM build
    # scripts also use realpath.
    set t [exec realpath --canonicalize-missing --no-symlinks --relative-to=. $m]

    # Get the extension (expecting .ip or .qsys) and convert to name format (IP or QSYS)
    set ext [string toupper [string trimleft [file extension $t] .]]

    # Emit dependence
    puts $ofile "set_global_assignment -name ${ext}_FILE $t"
  }

  if [info exists ::options::optionMap(--output)] {
    close $ofile
  }
  project_close
}


##
## Mode ip_lib and sync.
##
## Manage a shadow directory tree of all IP used in a build.
## This is required only because Quartus archives use the full
## path of IP source files, going through the link in the build
## area. Quartus resolves all other sources to the link.
## The result is an archive with the wrong root directory.
## Creating actual copies of IP instead of links works
## around the problem, at the expense of a more complicated
## setup flow.
##
## Mode ip_lib copies IP files from the git source tree to the project
## ../ip_lib/ tree. Mode sync is the opposite, copying sources from ../ip_lib/
## to the git source tree. Files are copied only if their modification time
## is newer than the target.
##
proc copyIP {mode verbose} {
  set project $::options::optionMap(--project)
  set revision $::options::optionMap(--revision)

  project_open -revision $revision $project

  if { ! [info exists ::env(OFS_ROOTDIR)] } {
    puts "OFS_ROOTDIR must be defined!"
    exit 1
  }
  if { ! [info exists ::env(BUILD_ROOT_REL)] } {
    puts "BUILD_ROOT_REL must be defined!"
    exit 1
  }

  # Get all the IP file paths in the project
  set ip_file [get_project_ip_files]

  foreach m $ip_file {
    # Convert absolute path to relative
    set t [exec realpath --canonicalize-missing --no-symlinks --relative-to=. $m]
    copySingleIP $t $mode $verbose
  }

  # Repeat the same loop for HEX_FILEs. They may be expected in the
  # same directory as IP to initialize memories.
  set glob_assign [get_all_assignments -type global -name HEX_FILE]
  foreach_in_collection a $glob_assign {
    # Path name
    set m [get_assignment_info $a -value]
    # Convert absolute path to relative
    set t [exec realpath --canonicalize-missing --no-symlinks --relative-to=. $m]
    copySingleIP $t $mode $verbose
  }

  project_close
}


## Called by copyIP above to copy a single IP file
proc copySingleIP {ip mode verbose} {
  if { [string first "../ip_lib" $ip] == 0 } {
    # The IP reference is in the legacy ../ip_lib tree.
    # Remove the leading part of the path, leaving only the portion
    # after ../ip_lib/.
    set src_file [file join $::env(OFS_ROOTDIR) [string range $ip 10 end]]
  } elseif { [file type $ip] == "link" } {
    # IP file reference is currently a link. Walk through all links until
    # the file is found.
    set src_file [exec realpath --canonicalize-missing $ip]
  } elseif { [file exists "${ip}.orig"] && [file type "${ip}.orig"] == "link" } {
    # The IP reference is a file and a link <IP file>.orig is present. This link
    # to the repository source was created during an earlier setup pass.
    set src_file [exec realpath --canonicalize-missing "${ip}.orig"]
  } else {
    # IP is a file and there is no clue where it came from. The source location
    # must be inferred from the path. Map the path in the project link tree back
    # to the source tree.
    set src_file [file join $::env(OFS_ROOTDIR) [exec realpath --canonicalize-missing --relative-to=$::env(BUILD_ROOT_REL) $ip]]
  }

  if { $mode == "ip_lib" } {
    # Target directory
    set tgt_dir [file dirname $ip]
    set tgt_file $ip

    # Record the original work tree link from the IP file to the source in case
    # it is needed on a later pass.
    if { [file exists $tgt_file] && [file type $tgt_file] == "link" } {
      set orig_link "${tgt_file}.orig"
      if { [file exists $orig_link] } {
        file delete -force $orig_link
      }
      file copy $tgt_file $orig_link
      file delete $tgt_file
    }
  } else {
    # In sync mode, copying from work tree to source repository. Reverse src_file
    # and tgt_file.
    set tgt_dir [file dirname $src_file]
    set tgt_file $src_file
    set src_file $ip
  }

  if { ! [file exists $src_file] } {
     puts "Warning: source file \"$src_file\" not found."
  } elseif { [file exists $tgt_file] && [file mtime $src_file] <= [file mtime $tgt_file] } {
      if { $verbose } { puts "Already present: $tgt_file" }
  } else {
    if { $verbose } {
      puts "Copy from: $src_file to $tgt_file"
    } else {
      puts "Copy from: $src_file"
    }

    file mkdir $tgt_dir
    file copy -force $src_file $tgt_file

    # Copy ancillary files as needed. Right now, that's only quartus.ini.
    foreach fn {quartus.ini} {
      set src_dir [file dirname $src_file]
      if { [file exists [file join $src_dir $fn]] } {
          file copy -force [file join $src_dir $fn] [file join $tgt_dir $fn]
      }
    }
  }
}


#************************************************
# Description: Entry point of TCL post processing
#************************************************
proc main {} {
  if { [::options::ParseCMDArguments {--project --revision} {--help --verbose --mode --output}] == -1 } {
    PrintHelp
    exit 1
  }

  if [info exists ::options::optionMap(--help)] {
    PrintHelp
    return 0
  }

  # Get the mode, if specified.
  if [info exists ::options::optionMap(--mode)] {
    set mode $::options::optionMap(--mode)
  } else {
    # Default
    set mode tcl
  }

  if [info exists ::options::optionMap(--verbose)] {
    set verbose $::options::optionMap(--verbose)
  } else {
    # Default
    set verbose 0
  }

  if { $mode == "tcl" } {
    emitIP
  } elseif { $mode == "ip_lib" || $mode == "sync" } {
    copyIP $mode $verbose
  } else {
    puts "Illegal mode: $mode"
    PrintHelp
    exit 1
  }
}

if { $::quartus(nameofexecutable) != "quartus_ipgenerate" } {
  puts ""
  puts "ERROR: emit_project_ip.tcl must be invoked from quartus_ipgenerate due to \[get_project_ip_files\]"
  puts "Aborting..."
  exit 1
}

main
