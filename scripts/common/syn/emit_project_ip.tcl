# Copyright 2022 Intel Corporation
# SPDX-License-Identifier: MIT

##
## Invoke from quartus_ipgenerate -t.
##
## Read the collection of IP files (IP and QSYS) from a project and emit
## a Tcl file that loads them into Quartus. OFS uses this script to pass
## the FIM's set of IP files from a base build to a PR build. OFS PR
## builds don't load FIM sources, unless required, so the FIM source
## specification of IPs can't be reused easily. Quartus requires access
## to all base build IP in a PR build. This script automates base build
## IP management in PR builds.
##

# Add tcl_lib subdirectory of this script to package search path
lappend auto_path [file join [pwd] [file dirname [info script]] tcl_lib]
# OFS script for parsing command line options
package require options


#************************************************
# Description: Print the HELP info
#************************************************
proc PrintHelp {} {
   puts "This script emits all the IP files defined in a project."
   puts "Usage: emit_project_ip.tcl --project=<proj> --revision=<rev> \[--output=fname\]"
   puts "                           \[--mode=<tcl|ip_lib|sync>\] \[--verbose=1\]"
   puts ""
   puts "Supported options:"
   puts "    --project=<project>"
   puts "    --revision=<revision>"
   puts "    --output=<output file>   (writes to stdout if not set)"
   puts "    --mode=<tcl|ip_lib|sync> (default: tcl)"
   puts "         tcl emits a Quartus Tcl script that loads the project's IP"
   puts "         ip_lib copies project IP into the ../ip_lib/ tree"
   puts "         sync copies project IP from the ../ip_lib/ tree back to the source IP"
   puts "    --verbose=1              (more information about file copying)"
   puts ""
   puts "Mode sync can be used after adding or upgrading IP within a Quartus project"
   puts "to move local IP files in ../ip_lib/ back to the git source tree."
}


proc emitIP {} {
  set project $::options::optionMap(--project)
  set revision $::options::optionMap(--revision)

  project_open -revision $revision $project
  set ip_file [get_project_ip_files]

  if [info exists ::options::optionMap(--output)] {
    set ofile [open $::options::optionMap(--output) w]
  } else {
    set ofile stdout
  }

  puts $ofile "##"
  puts $ofile "## IP inherited from the base FIM build from ${project} ${revision}"
  puts $ofile "##"
  puts $ofile "## Generated by OFS emit_project_ip.tcl"
  puts $ofile "##\n"

  foreach m $ip_file {
    # Unfortunately, Quartus converts IP file paths to absolute. We want the
    # paths to be relative. Use the realpath program to do this. The FIM build
    # scripts also use realpath.
    set t [exec realpath --canonicalize-missing --relative-to=. $m]

    # Get the extension (expecting .ip or .qsys) and convert to name format (IP or QSYS)
    set ext [string toupper [string trimleft [file extension $t] .]]

    # Emit dependence
    puts $ofile "set_global_assignment -name ${ext}_FILE $t"
  }

  if [info exists ::options::optionMap(--output)] {
    close $ofile
  }
  project_close
}


##
## Mode ip_lib and sync.
##
## Manage a shadow directory tree of all IP used in a build.
## This is required only because Quartus archives use the full
## path of IP source files, going through the link in the build
## area. Quartus resolves all other sources to the link.
## The result is an archive with the wrong root directory.
## Creating actual copies of IP instead of links works
## around the problem, at the expense of a more complicated
## setup flow.
##
## Mode ip_lib copies IP files from the git source tree to the project
## ../ip_lib/ tree. Mode sync is the opposite, copying sources from ../ip_lib/
## to the git source tree. Files are copied only if their modification time
## is newer than the target.
##
proc copyIP {mode verbose} {
  set project $::options::optionMap(--project)
  set revision $::options::optionMap(--revision)

  project_open -revision $revision $project

  # Get all the IP file paths in the project
  set ip_file [get_project_ip_files]

  foreach m $ip_file {
    # Convert absolute path to relative. We do this, despite simply
    # looking for /ip_lib/ below in case the user's work tree is also
    # under a directory named /ip_lib/. This is unlikely, but would be
    # difficult for a user to debug. A relative path guarantees that
    # the directories will be within the project hierarchy.
    set t [exec realpath --canonicalize-missing --relative-to=. $m]

    # Does the path contain /ip_lib/?
    set ip_lib_idx [string first "/ip_lib/" $m]
    if { $ip_lib_idx >= 0 } {
      # Remove the leading part of the path, leaving only the portion
      # after /ip_lib/. "$ip_lib_idx" is the index of the start of
      # "/ip_lib/" in "$m"
      set f_name [string range $m [expr $ip_lib_idx + 8] end]

      copySingleIP $f_name $mode $verbose
    }
  }

  # Repeat the same loop for HEX_FILEs. They may be expected in the
  # same directory as IP to initialize memories.
  set glob_assign [get_all_assignments -type global -name HEX_FILE]
  foreach_in_collection a $glob_assign {
    # Path name
    set m [get_assignment_info $a -value]
    # Convert absolute path to relative
    set t [exec realpath --canonicalize-missing --relative-to=. $m]

    # Does the path contain /ip_lib/?
    set ip_lib_idx [string first "/ip_lib/" $m]
    if { $ip_lib_idx >= 0 } {
      # Remove the leading part of the path.
      set f_name [string range $m [expr $ip_lib_idx + 8] end]

      copySingleIP $f_name $mode $verbose
    }
  }

  project_close
}


## Called by copyIP above to copy a single IP file
proc copySingleIP {ip mode verbose} {
  if { $mode == "ip_lib" } {
    # Location of real source file
    set src_file [file join $::env(OFS_ROOTDIR) $ip]
    # Target directory in ../ip_lib
    set tgt_dir [file join ../ip_lib [file dirname $ip]]
    set tgt_file [file join ../ip_lib $ip]
  } else {
    # Location of file in ../ip_lib
    set src_file [file join ../ip_lib $ip]
    # Target in source tree
    set tgt_dir [file join $::env(OFS_ROOTDIR) [file dirname $ip]]
    set tgt_file [file join $::env(OFS_ROOTDIR) $ip]
  }

  if { ! [file exists $src_file] } {
     puts "Warning: source file \"$src_file\" not found."
  } elseif { [file exists $tgt_file] && [file mtime $src_file] <= [file mtime $tgt_file] } {
      if { $verbose } { puts "Already present: $tgt_file" }
  } else {
    if { $verbose } {
      puts "Copy from: $src_file to $tgt_file"
    } else {
      puts "Copy from: $src_file"
    }

    file mkdir $tgt_dir
    file copy -force $src_file $tgt_file

    # Copy ancillary files as needed. Right now, that's only quartus.ini.
    foreach fn {quartus.ini} {
      set src_dir [file dirname $src_file]
      if { [file exists [file join $src_dir $fn]] } {
          file copy -force [file join $src_dir $fn] [file join $tgt_dir $fn]
      }
    }
  }
}


#************************************************
# Description: Entry point of TCL post processing
#************************************************
proc main {} {
  if { [::options::ParseCMDArguments {--project --revision} {--help --verbose --mode --output}] == -1 } {
    PrintHelp
    exit 1
  }

  if [info exists ::options::optionMap(--help)] {
    PrintHelp
    return 0
  }

  # Get the mode, if specified.
  if [info exists ::options::optionMap(--mode)] {
    set mode $::options::optionMap(--mode)
  } else {
    # Default
    set mode tcl
  }

  if [info exists ::options::optionMap(--verbose)] {
    set verbose $::options::optionMap(--verbose)
  } else {
    # Default
    set verbose 0
  }

  if { $mode == "tcl" } {
    emitIP
  } elseif { $mode == "ip_lib" || $mode == "sync" } {
    copyIP $mode $verbose
  } else {
    puts "Illegal mode: $mode"
    PrintHelp
    exit 1
  }
}

if { $::quartus(nameofexecutable) != "quartus_ipgenerate" } {
  puts ""
  puts "ERROR: emit_project_ip.tcl must be invoked from quartus_ipgenerate due to \[get_project_ip_files\]"
  puts "Aborting..."
  exit 1
}

main
