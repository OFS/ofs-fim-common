## Copyright (C) 2023 Intel Corporation
## SPDX-License-Identifier: MIT

##
## Script for dumping frequencies of an IOPLL IP file with qsys-script.
##
## Do not use the --script argument. Instead, invoke qsys-script with a
## project and system-file, adding:
##
##     --cmd="source <path to this script>; emit_ip_cfg <generated .vh file name> <subsystem name>"
## e.g.:
##     --cmd="source iopll_get_cfg.tcl; emit_ip_cfg sys_clk_cfg.vh SYS_CLK"
##
## The subsystem name is included in each symbol written to the .vh file"
##

package require qsys

proc emit_ip_cfg {ofile_name ip_name} {
    set of [open $ofile_name w]

    puts $of "//"
    puts $of "// Generated by OFS script iopll_get_cfg.tcl using qsys-script"
    puts $of "//"
    puts $of ""

    puts $of "`ifndef __OFS_FIM_IP_CFG_${ip_name}__"
    puts $of "`define __OFS_FIM_IP_CFG_${ip_name}__ 1"
    puts $of ""

    # Find the instance name in the IP's namespace (expecting one instance)
    set instances [get_instances]
    if { [llength $instances] != 1 } {
        send_message ERROR "Expected one instance in IOPLL IP"
        exit 1
    }
    set inst [lindex $instances 0]

    # Create an associative array of all the clock's parameters. It's easier
    # to manipulate the array than to probe the IP repeatedly. After this, the
    # script will just use the $clock() array.
    #
    # All the relevant parameters begin with "gui_", which is dropped when
    # generating array keys.
    foreach p [get_instance_parameters $inst] {
        if { [regexp "^gui_(.*)" $p match key] } {
            set clocks($key) [get_instance_parameter_value $inst $p]
        }
    }

    # Look for active PFs and VFs
    puts $of "//"
    puts $of "// Clock frequencies and names"
    puts $of "//"

    set n_clocks $clocks(number_of_clocks)

    # Loop through all clocks
    for {set clk_num 0} {$clk_num < $n_clocks} {incr clk_num} {
        # Exit when a clock name is undefined.
        if { ! [info exists clocks(clock_name_string${clk_num})] } { break }

        # Clock active?
        set mhz $clocks(output_clock_frequency${clk_num})
        if { $mhz > 0 } {
            set mhz_actual $clocks(actual_output_clock_frequency${clk_num})
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_CLK${clk_num}_NAME     $clocks(clock_name_string${clk_num})"
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_CLK${clk_num}_MHZ      $mhz_actual"
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_CLK${clk_num}_TGT_MHZ  $mhz"

            puts $of "// Same information, indexed by the clock's name"
            set clk_name [string toupper $clocks(clock_name_string${clk_num})]
            # Remove leading "CLK_" from name
            if { [string compare -length 4 $clk_name "CLK_"] == 0 } {
                set clk_name [string range $clk_name 4 1000]
            }
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_${clk_name}_NUM      $clk_num"
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_${clk_name}_MHZ      $mhz_actual"
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_${clk_name}_TGT_MHZ  $mhz"

            puts $of ""
        }
    }

    puts $of "`endif // `ifndef __OFS_FIM_IP_CFG_${ip_name}__"

    close $of
}
