## Copyright (C) 2023 Intel Corporation
## SPDX-License-Identifier: MIT

##
## Script for dumping state from a HSSI SS IP file with qsys-script for
## use by the OFS FIM.
##
## Do not use the --script argument. Instead, invoke qsys-script with a
## project and system-file, adding:
##
##     --cmd="source <path to this script>; emit_ip_cfg <generated .vh file name> <subsystem name>"
## e.g.:
##     --cmd="source hssi_ss_get_cfg.tcl; emit_ip_cfg hssi_ss_cfg.vh HSSI_SS"
##
## The subsystem name is included in each symbol written to the .vh file"
##

package require qsys

proc emit_ip_cfg {ofile_name ip_name} {
    set of [open $ofile_name w]

    puts $of "//"
    puts $of "// Generated by OFS script hssi_ss_get_cfg.tcl using qsys-script"
    puts $of "//"
    puts $of ""

    puts $of "`ifndef __OFS_FIM_IP_CFG_${ip_name}__"
    puts $of "`define __OFS_FIM_IP_CFG_${ip_name}__ 1"
    puts $of ""

    # Find the instance name in the IP's namespace (expecting "hssi_ss")
    set instances [get_instances]
    if { [llength $instances] != 1 } {
        send_message ERROR "Expected one instance in HSSI SS IP"
        exit 1
    }

    set inst [lindex $instances 0]
    array set port_enabled_arr {} 
    array set port_profile_arr {} 
    set lanes_per_port 1
    set eth_packet_width 64
    set port_profile ""
    foreach p [get_instance_parameters $inst] {
        if { [string equal $p "NUM_ENABLED_PORTS"] } {
            set num_eth_ports [get_instance_parameter_value $inst $p]
        }
        if { [regexp {PORT([0-9]+)_ENABLED_GUI} $p key w] } {
            # Remove everything except the integer (0-15) from
            # the parameter 'PORT<n>_ENABLED_GUI
            set key_num [string trim $key "_ENABLED_GUI"]
            set key_num [string trim $key_num "PORT"]
            set is_en [get_instance_parameter_value $inst $p]
            #if the port is enabled, save the profile and packet width
            set port_enabled_arr($key_num) $is_en
            set port_profile_concat "PORT$key_num\_PROFILE_GUI"
            set port_profile [get_instance_parameter_value $inst $port_profile_concat]
            set port_profile_arr($key_num) $port_profile
            if {$is_en} {
               set hssi_config $port_profile 
               if {$port_profile == "100GCAUI-4"} {
                   # mark
                   set lanes_per_port 4 
                   set eth_packet_width 512
               } elseif {$port_profile == "200GAUI-4"} {
                   set lanes_per_port 4 
                   set eth_packet_width 512
               } elseif {$port_profile == "400GAUI-8"} {
                   set lanes_per_port 8
                   set eth_packet_width 1024
               }
            }
        }
    }

    puts $of "//"
    puts $of "// The OFS_FIM_IP_CFG_<ip_name>_ETH_PORTS macro will be defined iff the"
    puts $of "// port is active. The value does not have to be tested."
    puts $of "//"

    puts $of ""
    puts $of "//"
    puts $of "// The macros below represent the raw eth port configuration above in"
    puts $of "// ways that are easier to process in SystemVerilog loops."
    puts $of "//"
    puts $of ""

    if {$hssi_config =="200GAUI-4"} {
          puts $of "`define ETH_200G"  
	  puts $of "`define MAC_SEGMENTED"
    } elseif {$hssi_config =="400GAUI-8"} {
          puts $of "`define ETH_400G"
	  puts $of "`define MAC_SEGMENTED"
    } elseif {$hssi_config =="100GCAUI-4"} {
          puts $of "`define ETH_100G"
    } elseif {$hssi_config == "100GCAUI-2"} {
          puts $of "`define ETH_50G"
    } elseif {$hssi_config ==   "10GbE"} {
          puts $of "`define ETH_10G"
    } elseif {$hssi_config ==  "25GbE"} {
          puts $of "`define ETH_25G"
    } else {
          puts $of "`define ETH_25G"
    }
    

    set num_lanes 0
    set num_port_cnt 0
    set max_port_num 0 
    # Get the highest port number
    set total_ports 0
    for {set i 0}  { $i <= 16 } {incr i} {
       if { $port_enabled_arr($i) == 1 } {
          set total_ports [expr $total_ports + $lanes_per_port]
          set max_port_num [expr $i + $lanes_per_port - 1] 
       } 
    }
    # Save the total number of enabled ports
    # Save the maximum enabled port number
    # Construct an array that enumerates the enabled ports.   
    set enum_port_idx(0) 0

    # Loop through all Ports.  Instantiate each enabled port in the 
    # hssi_ss instantiation. 
    puts $of ""
    puts $of ""
    puts $of "`define INST_ALL_PORTS \\"
    for { set i 0 } { $i <= $max_port_num } { incr i } {
       if { $port_enabled_arr($i) == 1 } {
          puts $of "   `HSSI_PORT_INST($i) \\"
       }
    }

     
    # Loop through all Ports.  define the INCLUDE_HSSI_PORT_<n> macros
    # for UVM. 
    puts $of ""
    puts $of ""
    for { set i 0 } { $i <= $max_port_num } { incr i } {
       if { $port_enabled_arr($i) == 1 } {
          puts $of "`define INCLUDE_HSSI_PORT_$i "
       }
    }

    # Create an enumerated type for hssi_wrapper. 
    # Only include the enabled ports. 
    puts $of ""
    puts  -nonewline $of "`define ENUM_PORT_INDEX "
    for { set i 0 } { $i <= $max_port_num } { incr i } {
       if { $port_enabled_arr($i) == 1 } {
           puts -nonewline $of "PORT_$i, "
       } 
    }

    puts $of ""
    puts $of ""
    puts $of "// Total number of ports, not necessarily dense (see MAX_PORT_NUM)"
    puts $of "`define OFS_FIM_IP_CFG_${ip_name}_NUM_ETH_PORTS ${num_eth_ports}"
    puts $of "`define OFS_FIM_IP_CFG_${ip_name}_ETH_PACKET_WIDTH ${eth_packet_width}"
    puts $of "`define OFS_FIM_IP_CFG_${ip_name}_NUM_LANES ${lanes_per_port}"
    
    puts $of ""
    puts $of ""
    puts $of "`endif // `ifndef __OFS_FIM_IP_CFG_${ip_name}__"

    close $of
}
