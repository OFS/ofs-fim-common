## Copyright (C) 2023 Intel Corporation
## SPDX-License-Identifier: MIT

##
## Script for composing a description of the channel interfaces of a Memory Subsystem IP file with qsys-script.
## This is used to configure the OFS reference design to match an IP configuration.
## The reference design only supports homogenous channel instantiation and does not support Associative Storage
## application channels. Designs that require more elaborate channel configuration are instructed to implement
## their own subsystem design integration.
##
## Do not use the --script argument. Instead, invoke qsys-script with a
## project and system-file, adding:
##
##     --cmd="source <path to this script>; emit_ip_cfg <generated .vh file name> <subsystem name>"
## e.g.:
##     --cmd="source mem_ss_get_cfg.tcl; emit_ip_cfg mem_ss_cfg.vh MEM_SS"
##
## The subsystem name is included in each symbol written to the .vh file"
##

package require qsys

# List copy
proc lcopy {dest src} {
    upvar $dest mydest $src mysrc
    foreach key [ array names mysrc ] {
        set mydest($key) $mysrc($key)
    }
    return
}

# Compare list A and B
proc lcompare {a b} {
    upvar $a my_a $b my_b
    if { [array size my_a] != [array size my_b] } {
        return 0
    }

    foreach {key val} [array get my_a] {
        if { ![info exists my_b($key)] } {
            return 0
        }
        if { $my_b($key) != $val } {
            return 0
        }
    }

    return 1
}

proc emit_ip_cfg {ofile_name ip_name} {
    set of [open $ofile_name w]

    puts $of "//"
    puts $of "// Generated by OFS script mem_ss_get_cfg.tcl using qsys-script"
    puts $of "//"
    puts $of ""

    puts $of "`ifndef __OFS_FIM_IP_CFG_${ip_name}__"
    puts $of "`define __OFS_FIM_IP_CFG_${ip_name}__ 1"
    puts $of ""

    # Find the instance name in the IP's namespace (expecting one instance)
    set instances [get_instances]
    if { [llength $instances] != 1 } {
        send_message ERROR "Expected one instance in Memory Subsystem IP"
        exit 1
    }

    set inst [lindex $instances 0]
    set inst_entity [get_instance_property $inst CLASS_NAME]
    
    # Message for deprecated IP
    if { [string equal $inst_entity "mem_ss_fm"] } {
        send_message WARNING "${inst_entity} is provided by Quartus as a beta version and support in OFS is subject to change in the future"
    }

    # Read IP parameters
    foreach p [get_instance_parameters $inst] {
        #################################################################
        # Parameter parsing for deprecated IP
        if { [string equal $p "NUM_OF_PHYSICAL_INTERFACES"] } {
            set num_mem_phy [get_instance_parameter_value $inst $p]
        }

        if { [string equal "DIAG_ENABLE_CSR" $p ] } {
            if { [get_instance_parameter_value $inst $p] } {
                puts $of "// Connect Memory Subsystem to AXI-Lite CSR fabric "
                puts $of "`define OFS_FIM_IP_CFG_${ip_name}_EN_CSR"
            }
        }
        # Process per channel params
        # HPS or EMIF?
        if { [regexp "^MEM_TYPE_ENUM_(.*)" $p match channel] } {
            set channel_type($channel) [get_instance_parameter_value $inst $p]
        }
        # Remove once mem_ss_fm IP is no longer available
        #################################################################

        # Parameter parsing for officially supported IP
        if { [string equal "MEM_INTFS_TYPE" $p] } {
            # A space-separated list of memory PHY channel types
            set mem_channels [split [get_instance_parameter_value $inst $p]]
        }

        if { [string equal "APP_INTFS_TYPE" $p] } {
            # A space-separated list of memory application channel types
            # OFS currently only supports STORAGE (AXI-MM) and HPS
            set app_channels [split [get_instance_parameter_value $inst $p]]
        }

        if { [string equal "ENABLE_MEM_CSR_INTF" $p ] } {
            # Enable routing to Subsystem CSR interface
            if { [string equal "ENABLED" [get_instance_parameter_value $inst $p]] } {
                puts $of "// Connect Memory Subsystem to AXI-Lite CSR fabric "
                puts $of "`define OFS_FIM_IP_CFG_${ip_name}_EN_CSR"
            }
        }
        if { [regexp "^MEM_CH_(.*)_CONNS" $p match channel] } {
            # The application->physical channel connections. Use to determine which channel HPS is connected to.
            set channel_conns($channel) [get_instance_parameter_value $inst $p]
        }
    }

    #################################################################
    # Map old IP param structures to new IP
    # The old IP will only ever support DDR4 and 1-to-1 application-to-mem channel mapping
    if { [string equal $inst_entity "mem_ss_fm"] } {
        for {set channel 0} { $channel < $num_mem_phy } {incr channel} {
            lappend channel_conn_list 0
        }

        for {set channel 0} { $channel < $num_mem_phy } {incr channel} {
            if { [string equal $channel_type($channel) "MEM_TYPE_HPS_EMIF_DDR4"] } {
                lappend app_channels "HPS"
                set channel_conns($channel) [lreplace $channel_conn_list $channel $channel 1]
            } else {
                lappend app_channels "STORAGE"
            }
            lappend mem_channels "DDR4"
        }
    }
    # Remove once mem_ss_fm IP is no longer available
    #################################################################

    puts $of ""
    puts $of "//"
    puts $of "// Flags to enable memory channel instantiation/configuration "
    puts $of "//"

    puts $of "`define OFS_FIM_IP_CFG_${ip_name}_ENTITY ${inst_entity}"

    # Interpret mem_ss channel interface parameters
    set num_axi_channels 0
    for {set channel 0} { $channel < [llength $app_channels] } {incr channel} {
        set type [lindex $app_channels $channel]
        if { [string equal "ASSOCIATIVE_STORAGE" $type] } {
            send_message ERROR "Memory Subsystem lookup interface is unsupported in the OFS reference FIM!"
            exit 1
        }

        if { [string equal "STORAGE" $type] } {
            set interface "i${channel}_axi_mm"
            foreach port [get_interface_ports $interface] {
                # Clean the AXI-MM port name of subsystem prefix (i#_ ss_ app_) mm_
                set axi_port [string trimleft [string trimleft $port "i${channel}sap_"] "m_"]
                set axi_ch_width($axi_port) [get_interface_port_property $interface $port WIDTH]
            }
            if { [info exists axi_width] } {
                if { ![lcompare axi_width axi_ch_width] } {
                    send_message ERROR "Mismatched Memory Subsystem channel settings are unsupported in the OFS reference FIM!"
                    exit 1
                }
            } else {
                lcopy axi_width axi_ch_width
            }
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_EN_AXI_MM_${channel}"
            incr num_axi_channels
        }
        if { [string equal "HPS" $type] } {
            # Search channel connection map for the channel attached to HPS
            # Agilex HPS only supports 1 HPS channel so no need to search all
            set hps_channel [lsearch [split $channel_conns(${channel})] "1"]
        }
    }

    # mem_ss interface ports
    set num_ddr4_channels 0
    for {set channel 0} { $channel < [llength $mem_channels] } {incr channel} {
        set type [lindex $mem_channels $channel]
        if { ![string equal "DDR4" $type] } {
            send_message ERROR "Unsupported memory type ${type} assigned to Memory Channel ${channel}!"
            exit 1
        }

        if { [info exists hps_channel] && ($hps_channel == $channel) } {
            set interface "mem${channel}_ddr4"
            foreach port [get_interface_ports $interface] {
                # Clean the DDR4 port name of subsystem prefix (mem#_ ddr4_)
                set mem_port [string trimleft [string trimleft [string trimleft $port "mem${channel}_"] "ddr4"] "_"]
                set hps_width($mem_port) [get_interface_port_property $interface $port WIDTH]
            }
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_HPS_EMIF_IS_MEM_${channel}"
        } else {
            set interface "mem${channel}_ddr4"
            foreach port [get_interface_ports $interface] {
                # Clean the DDR4 port name of subsystem prefix (mem#_ ddr4_)
                set mem_port [string trimleft [string trimleft [string trimleft $port "mem${channel}_"] "ddr4"] "_"]
                set ddr4_ch_width($mem_port) [get_interface_port_property $interface $port WIDTH]
            }
            if { [info exists ddr4_width] } {
                if { ![lcompare ddr4_width ddr4_ch_width] } {
                    send_message ERROR "Mismatched memory subsystem channel settings are unsupported in the OFS reference FIM!"
                    exit 1
                }
            } else {
                lcopy ddr4_width ddr4_ch_width
            }

            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_EN_MEM_${channel}"
            incr num_ddr4_channels
        }
    }

    # Define the AXI-MM interface widths
    # Filter AXI ports for the ones that are user configurable
    set axi_ports {rdata wdata awlen awuser awid awaddr buser}
    if { [info exists axi_width] } {
        puts $of ""
        puts $of "//"
        puts $of "// AXI-MM user interface configuration "
        puts $of "//"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DEFINES_USER_AXI"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_NUM_AXI_CHANNELS ${num_axi_channels}"
        foreach port $axi_ports {
            if { [string first "data" $port] != -1 } {
                # Memory supports assymetric read/write data widths
                set PORT [string toupper $port]
            } elseif { [string first "buser" $port] != -1 } {
                set PORT [string toupper $port]
            } else {
                # Otherwise clean the channel specific prefix from the AXI port
                set PORT [string toupper [string trimleft [string trimleft $port "a"] "w"]]
            }
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_AXI_${PORT}_WIDTH $axi_width($port)"
        }
    }

    # Define the PHY interfaces
    # Define the Fabric EMIF DDR4 interface widths
    if { [info exists ddr4_width] } {
        puts $of ""
        puts $of "//"
        puts $of "// Fabric EMIF interface configuration "
        puts $of "//"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DEFINES_EMIF_DDR4"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_NUM_DDR4_CHANNELS ${num_ddr4_channels}"
        foreach {port width} [array get ddr4_width] {
            set PORT [string toupper $port]
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DDR4_${PORT}_WIDTH $width"
        }
    }

    # define the HPS EMIF DDR4 interface widths
    if { [info exists hps_width] } {
        puts $of ""
        puts $of "//"
        puts $of "// HPS EMIF interface configuration "
        puts $of "//"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DEFINES_HPS_DDR4"
        foreach {port width} [array get hps_width] {
            set PORT [string toupper $port]
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_HPS_${PORT}_WIDTH $width"
        }
    }

    puts $of ""
    puts $of "`endif // `ifndef __OFS_FIM_IP_CFG_${ip_name}__"

    close $of
}
