## Copyright (C) 2023 Intel Corporation
## SPDX-License-Identifier: MIT

##
## Script for dumping channel mapping of a Memory Subsystem IP file with qsys-script.
##
## Do not use the --script argument. Instead, invoke qsys-script with a
## project and system-file, adding:
##
##     --cmd="source <path to this script>; emit_ip_cfg <generated .vh file name> <subsystem name>"
## e.g.:
##     --cmd="source mem_ss_get_cfg.tcl; emit_ip_cfg mem_ss_cfg.vh MEM_SS"
##
## The subsystem name is included in each symbol written to the .vh file"
##

package require qsys

# List copy
proc lcopy {dest src} {
    upvar $dest mydest $src mysrc
    foreach key [ array names mysrc ] {
        set mydest($key) $mysrc($key)
    }
    return
}

# Compare list A and B
proc lcompare {a b} {
    upvar $a my_a $b my_b
    if { [array size my_a] != [array size my_b] } {
        return 0
    }

    foreach {key val} [ array get my_a] {
        if { ![info exists my_b($key)] } {
            return 0
        }
        if { $my_b($key) != $val } {
            return 0
        }
    }

    return 1
}

proc emit_ip_cfg {ofile_name ip_name} {
    set of [open $ofile_name w]

    puts $of "//"
    puts $of "// Generated by OFS script mem_ss_get_cfg.tcl using qsys-script"
    puts $of "//"
    puts $of ""

    puts $of "`ifndef __OFS_FIM_IP_CFG_${ip_name}__"
    puts $of "`define __OFS_FIM_IP_CFG_${ip_name}__ 1"
    puts $of ""

    # Find the instance name in the IP's namespace (expecting one instance)
    set instances [get_instances]
    if { [llength $instances] != 1 } {
        send_message ERROR "Expected one instance in Memory Subsystem IP"
        exit 1
    }
    set inst [lindex $instances 0]

    # Determine the number of physical DDR channels connected
    foreach p [get_instance_parameters $inst] {
        if { [string equal $p "NUM_OF_PHYSICAL_INTERFACES"] } {
            set num_ddr_channels [get_instance_parameter_value $inst $p]
        }

        if { [string equal "DIAG_ENABLE_CSR" $p ] } {
            # set csr_en 
            if { [get_instance_parameter_value $inst $p] } {
                puts $of "// Connect Memory Subsystem to AXI-Lite CSR fabric "
                puts $of "`define OFS_FIM_IP_CFG_${ip_name}_EN_CSR"
            }
        }

        # Process per channel params
        # HPS or EMIF?
        if { [regexp "^MEM_TYPE_ENUM_(.*)" $p match channel] } {
            set channel_type($channel) [get_instance_parameter_value $inst $p]
        }
    }

    puts $of ""
    puts $of "//"
    puts $of "// Flags to enable memory channel instantiation/configuration "
    puts $of "//"

    set num_mem_channels $num_ddr_channels

    set ddr_ports {a ba bg ck cke cs_n odt dq}
    set axi_ports {wdata wuser awlen awid awaddr}

    # Loop through all the memory channels and determine which connection flag to use
    foreach {channel type} [array get channel_type] {
        if { $channel >= $num_ddr_channels } {
            continue
        }
        if { [string equal $type "MEM_TYPE_HPS_EMIF_DDR4"] } {
            if { [info exists hps_width] } {
                send_message ERROR "Unable to parse Memory Subsystem configuration. There can only be one HPS EMIF in the design!"
                exit 1
            }
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_HPS_EMIF_IS_MEM_${channel}"
            incr num_mem_channels -1
            # DDR4
            foreach port $ddr_ports {
                set hps_width($port) [get_interface_port_property mem${channel}_ddr4 mem${channel}_ddr4_${port} WIDTH]
            }
        } else {
            # DDR4
            if { [string equal $type "MEM_TYPE_EMIF_DDR4"] } {
                foreach port $ddr_ports {
                    set ddr_ch_width($port) [get_interface_port_property mem${channel}_ddr4 mem${channel}_ddr4_${port} WIDTH]
                }
            } else {
                send_message ERROR "Unsupported memory type ${type} assigned to MEM_TYPE_ENUM_${channel}!"
                exit 1
            }

            # Extract fabric interface widths:
            # User AXI-MM (read/write channels are symmetric)
            foreach port $axi_ports {
                set axi_ch_width($port) [get_interface_port_property i${channel}_axi_mm i${channel}_app_ss_mm_${port} WIDTH]
            }

            if { [info exists ddr_width] } {
                if { ![lcompare ddr_width ddr_ch_width] || ![lcompare axi_width axi_ch_width] } {
                    send_message ERROR "Mismatched memory subsystem channel settings are unsupported in the OFS reference FIM!"
                    exit 1
                }
            } else {
                lcopy axi_width axi_ch_width
                lcopy ddr_width ddr_ch_width
            }
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_EN_MEM_${channel}"
        }
    }

    puts $of "`define OFS_FIM_IP_CFG_${ip_name}_NUM_MEM_CHANNELS $num_mem_channels"

    # define the AXI-MM interface widths
    if { [info exists axi_width] } {
        puts $of ""
        puts $of "//"
        puts $of "// AXI-MM user interface configuration "
        puts $of "//"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DEFINES_USER_AXI 1"
        foreach port $axi_ports {
            set PORT [string toupper [string trimleft [string trimleft $port "a"] "w"]]
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_AXI_${PORT}_WIDTH $axi_width($port)"
        }
    }

    # define the Fabric EMIF DDR4 interface widths
    if { [info exists ddr_width] } {
        puts $of ""
        puts $of "//"
        puts $of "// Fabric EMIF interface configuration "
        puts $of "//"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DEFINES_EMIF_DDR4 1"
        foreach port $ddr_ports {
            set PORT [string toupper $port]
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DDR4_${PORT}_WIDTH $ddr_width($port)"
        }
    }

    # define the HPS EMIF DDR4 interface widths
    if { [info exists hps_width] } {
        puts $of ""
        puts $of "//"
        puts $of "// HPS EMIF interface configuration "
        puts $of "//"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DEFINES_HPS_DDR4 1"
        foreach port $ddr_ports {
            set PORT [string toupper $port]
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_HPS_${PORT}_WIDTH $hps_width($port)"
        }
    }

    puts $of ""
    puts $of "`endif // `ifndef __OFS_FIM_IP_CFG_${ip_name}__"

    close $of
}
