# Sample Partial Reconfiguration AFU

The example here is intended to illustrate how the available tools and interfaces
fit together. It mixes and matches multiple design choices into a single example.

The PR build tree generated by ./syn/build\_top.sh's "-p" switch is a template
for configuring a build, derived from a synthesized FIM. That template includes the
Platform Interface Manager (PIM), though use of the PIM is not mandatory. Its sources
are loaded by the template, but the namespace is designed not to clash with other build
flows. The scripts that are provided with the PIM, such as afu\_synth\_setup, could be
used just to replicate the template tree in preparation for adding new sources by hand
or using Platform Designer. In addition to the usual PIM flow, you could pick any small
sample application, use afu\_synth\_setup to instantiate a build tree and then edit the
build tree. You could also define a build that contains just a mandatory JSON
descriptor file and use it to generate an empty build tree.

The ASE simulation environment emulates the ofs\_plat\_if FIM interface wrapper that is
passed to the PIM. This interface is a relatively simple wire mapping of a platform's
PR boundary. AFUs that code to this interface may choose to use PIM components but
may also connect directly to ofs\_plat\_if objects -- managing details such as PCIe
TLPs directly. As long as an AFU uses ofs\_plat\_afu() as its top-level module
and connects to the ofs\_plat\_if wrapper, it can be synthesized and simulated with
the same tools as full PIM-based AFUs.

The example here is such an application. The top-level ofs\_plat\_afu() module
connects one PCIe virtual function (VF) port to the standard host exerciser loopback
module. If another virtual function and a bank of local memory are available, the code
instantiates a second virtual function as the host exerciser's local memory variant.
Despite connecting directly to the TLP interface, the code uses the PIM to map a
bank of local memory to the PCIe clock domain and to transform the memory's interface
to Avalon-MM.

While generating TLPs directly is possible, as illustrated by this example, it may not
be the ideal choice for many applications. The PIM offers translation to memory mapped
interfaces, response sorting, burst mapping, separation of DMA from MMIO, and clock
management. It also manages independent DMA read and write channels into the FIM,
intended to optimize arbitration across multiple active VFs.

To build this example:

* Synthesize a FIM that supports PR using the ./syn/build\_top.sh script. Either use
the "-p" switch with build\_top.sh, which generates the PR build environment at the
top of the work tree as "pr\_build\_template", or generate the PR build environment
from an existing work tree with ./scripts/common/syn/generate\_pr\_release.sh. The
generated PR build tree is portable, including across sites, independent of the rest
of a work tree.

* Set the OPAE\_PLATFORM\_ROOT environment variable to the PR build tree path. For example:

```bash
export OPAE_PLATFORM_ROOT=${OFS_ROOTDIR}/work_d5005/pr_build_template
```

* Ensure that the OPAE SDK is installed, which contains afu\_synth\_setup.

* Use [filelist.txt](filelist.txt) in the directory here, along with afu\_synth\_setup or
afu\_sim\_setup, to configure a build tree. Use of these scripts and the generated build
tree are described in the [AFU development tutorial](https://github.com/OPAE/intel-fpga-bbb/tree/master/samples/tutorial/01_hello_world).
